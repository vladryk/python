
  функции и методы в Python — это практически одно и то же, за исключением того, что методы всегда
ожидают первым параметром ссылку на сам объект (self).

  Перегрузка операторов — один из способов реализации полиморфизма, когда мы можем задать свою реализацию
какого-либо метода в своём классе.
Например, у нас есть два класса:

class A:
    def go(self):
        print('Go, A!')

class B(A):
    def go(self, name):
        print('Go, {}!'.format(name))

В данном примере класс B наследует класс A, но переопределяет метод go,
поэтому он имеет мало общего с аналогичным методом класса A.


  Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным).
Инкапсуляция делает некоторые из компонент доступными только внутри класса. Инкапсуляция в Python работает лишь
на уровне соглашения между программистами о том, какие атрибуты являются общедоступными, а какие — внутренними.
Одиночное подчеркивание в начале имени атрибута говорит о том, что переменная или метод не предназначен для
использования вне методов класса, однако атрибут доступен по этому имени.
Двойное подчеркивание в начале имени атрибута даёт большую защиту: атрибут становится недоступным по этому имени.
Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем _ИмяКласса__ИмяАтрибута

  Наследование подразумевает то, что дочерний класс содержит все атрибуты родительского класса, при этом некоторые
из них могут быть переопределены или добавлены в дочернем.

  Полиморфизм - разное поведение одного и того же метода в разных классах. Например, мы можем сложить два числа,
и можем сложить две строки. При этом получим разный результат, так как числа и строки являются разными классами.


SOLID (https://habrahabr.ru/post/208442/)

Принцип единственной ответственности (Single responsibility)
«На каждый объект должна быть возложена одна единственная обязанность»
Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный класс.
Принцип открытости/закрытости (Open-closed)
«Программные сущности должны быть открыты для расширения, но закрыты для модификации»
Для этого представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.
Принцип подстановки Барбары Лисков (Liskov substitution)
«Объекты в программе могут быть заменены их наследниками без изменения свойств программы»
Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не соблюдается
Принцип разделения интерфейса (Interface segregation)
«Много специализированных интерфейсов лучше, чем один универсальный»
Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если необходимо — разбиваем интерфейсы.
Принцип инверсии зависимостей (Dependency Invertion)
«Зависимости должны строится относительно абстракций, а не деталей»
Проверяем, зависят ли классы от каких-то других классов(непосредственно инстанцируют объекты других классов и т.д) и если эта зависимость имеет место, заменяем на зависимость от абстракции.



